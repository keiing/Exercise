<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="animation/corscss.css">
</head>

<body>
  <h1>快速排序</h1>
  <div>
    <img src="animation/快速排序.gif" alt=""><br />
    <img src="animation/快速排序" alt="">
  </div>
  <div id='inner'></div>
  <script>
    var arr = [1, 454, 536543, 6457654765, 58758758, 76587685, 67456456]
    arr => {
      const len = arr.length
      if (len < 2) {
        return arr
      }
      const pivot = arr[0]
      const left = []
      const right = []
      for (let i = 1; i < len; ++i) {
        if (arr[i] >= pivot) {
          right.push(arr[i])
        }
        if (arr[i] < pivot) {
          left.push(arr[i])
        }
      }
      return [...quickSort(left), pivot, ...quickSort(right)]//递归排序
    }
    console.log(arr)
    /*
    快速排序（Quicksort），又称 划分交换排序（partition-exchange sort） 。

    快速排序（Quicksort） 在平均状况下，排序 n 个项目要 O(n log n) 次比较。在最坏状况下则需要 O(n2) 次比较，但这种状况并不常见。事实上，快速排序 O(n log n) 通常明显比其他算法更快，因为它的 内部循环（inner loop） 可以在大部分的架构上很有效率地达成。

    快速排序使用 分治法（Divide and conquer） 策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。
    */
    /*
    原理：随便选一个数，把原数组里比这个数小的放左边，比这个数大的放右边，然后再把左边和右边的数组重复上面的操作，最后完成排序
    */
    var newArr = [131, 6, 2, 4, 12, 52, 31, 42, 51, 424, 13213];
    //网上见的阮一峰大佬
    function quickSort(arr) {
      if (arr.length <= 1) {
        return arr;
      }
      var midI = Math.floor((arr.length - 1) / 2); //随便取了个数，这里拿了中间的index
      var mid = arr.splice(midI, 1)[0]; //拿到中间的数，同时把原数组这个数删掉
      var left = []; //用来存放比这个数小的数组
      var right = []; //用来存放比这个数大的数组
      for (var i = 0; i < arr.length; i++) { //循环原数组，把数放进数组里
        if (arr[i] < mid) {
          left.push(arr[i])
        } else {
          right.push(arr[i])
        }
      }
      return quickSort(left).concat([mid], quickSort(right)) //递归排序
    }
    console.time('quickSort')
    console.log(quickSort(newArr))
    console.timeEnd('quickSort')
    /*
    当面对一个有大量重复的数据的序列时，选取 pivot 的快速排序有可能会退化成一个 O(n²) 的算法
    */
  </script>
</body>

</html>