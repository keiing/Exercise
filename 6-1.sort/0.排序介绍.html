<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <h1>
        根据时间复杂度的不同，常见的算法可以分为3大类。
    </h1>
    <div style="border: 1px solid #000;">
        <h5>一个算法在N规模下所消耗的时间消耗从大到小如下：</h5>
        <h5 style="color:red;">O(1) < O(log n) < O(n) < O(n log n) < O(n2) < O(n3) < O(2n) </h5> <ol>
    </div>
    <ol>
        <li>
            <ul>

                <li>
                    <h2>O(n) 的排序算法</h2>
                </li>
                <li>冒泡排序</li>
                <li>选择排序</li>
                <li>插入排序</li>
                <li>希尔排序</li>
            </ul>
        </li>
        <li>
            <ul>
                <li>
                    <h2>O(n log n) 的排序算法</h2>
                </li>
                <li>并归排序</li>
                <li>快速排序</li>
                <li>堆排序</li>

            </ul>
        </li>
        <li>
            <ul>
                <li>
                    <h2>线性的排序算法</h2>
                </li>
                <li>计数排序</li>
                <li>桶排序</li>
                <li>基数排序</li>
            </ul>
        </li>
    </ol>
    <ul>
        <h3>常见概念：</h3>
        <li>最好时间复杂度： 在最理想情况下执行代码的时间复杂度，它花的时间最短；</li>
        <li>最坏时间复杂度： 最糟糕情况下执行代码的时间复杂度，它花的时间最长；</li>
        <li>平均时间复杂度： 执行代码时间的平均水平，这个值就是概率论中的加权平均值，也叫期望值。</li>
    </ul>
    <h3>名词解释：</h3>
    <ol>
        <li>In-place ：占用常数内存，不占用额外内存；</li>
        <li>Out-place ：占用额外内存；</li>
        <li>n：要被排序的纪录数量；</li>
        <li>k：不同键值的数量；</li>
        <li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同。</li>
    </ol>
    <hr>
    <!-- 分割线 -->
    <p style="text-align: center">页面按大小排序</p>
    <hr>
    <p>排序前</p>
    <ul id="SortUlD">
        <li>42</li>
        <li>72</li>
        <li>13</li>
        <li>22</li>
        <li>99</li>
    </ul>
    <p>排序后</p>
    <ul id='ulSortD'></ul>
    <hr>
    <p style="text-align: center">页面按长度排序</p>
    <hr>
    <p>排序前</p>
    <ul id='SortUlLength'>
        <li>421</li>
        <li>722</li>
        <li>134</li>
        <li>22.425</li>
        <li>99.23131</li>
    </ul>
    <p>排序后</p>
    <ul id='ulSortLength'></ul>
    <script>
        //使用setTimeout实现功能 性价比低
        //实用性低
        let list = [3, 4, 5, 8, 9, 7, 1, 3, 4, 3, 6]
        let arr = [];
        console.time('Sort');
        list.forEach(val => {
            setTimeout(function () {
                arr.push(val);
            }, val * 1)
        })
        setTimeout(() => console.log(arr), 1000)
        console.timeEnd('Sort');

        //js封装API sort
        let newArr = [1, 45425, 67687, 98989809, 314235, 425453, 24334321]
        newArr = newArr.sort((a, b) => a - b);
        console.time('Sort');
        console.log(newArr)
        console.timeEnd('Sort');

        //如果是按照长度排序
        let arrLength = ["abwaerewarwaerwa1321", '2454251341141341awaerbaw', 24542525, 245141, 2324, 2454251, 2452452, 324322222222];
        arrLength.sort((a, b) => {
            var { a, b } = { a: String(a), b: String(b) }
            return a.length - b.length
        });
        console.time('Sort');
        console.log(arrLength)
        console.timeEnd('Sort');
    </script>
    <!-- li页面排序按大小排序 -->
    <script>
        // 前提没有复杂的class 样式 id样式
        let html;
        let SortUlD = document.getElementById('SortUlD');
        //1.获取页面内容
        html = SortUlD.innerHTML;
        //2.去除头尾身体Li
        html = html.replace(/(^\s*<li>)|(<\/li>\s*$)/g, "");
        //3.进行切割
        html = html.split(/<\/li>\s*<li>/g);
        //4.排序
        html.sort((a, b) => a - b);
        //5.之后使用字符串拼接 
        html = '<li>' + html.join('</li><li>') + '</li>';
        //6.保存到要存放的/或者原来的位置
        let ulSortD = document.getElementById('ulSortD');
        ulSortD.innerHTML = html;
        ulSortD.nextElementSibling.innerHTML = '这是使用js排序的<span style="color:red">------</span>仔细看的同学会发现这是个hr标签';
    </script>
    <!-- li页面按长度排序 -->
    <script>
        let SortUlLength = document.getElementById('SortUlLength');
        //1.获取页面内容
        html = SortUlLength.innerHTML;
        //2.替换开头的li标签和结尾的li标签
        html = html.replace(/(^\s*<li>)|(<\/li>\s*$)/g, "");
        //3.进行切割 </li>到<li>中的空格都去除
        html = html.split(/<\/li>\s*<li>/g);
        //4.进行长度排序
        html.sort((a, b) => a.length - b.length);
        //5.使用字符串拼接恢复切割前的状态
        html = '<li>' + html.join('</li><li>') + '</li>';
        //nextElementSibling下一个兄弟
        SortUlLength.nextElementSibling.nextElementSibling.innerHTML = html;
    </script>

</body>

</html>